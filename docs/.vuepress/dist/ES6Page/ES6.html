<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>ES6 | 吴炫境个人博客</title>
    <meta name="generator" content="VuePress 1.9.10">
    
    <meta name="description" content="代码学习记录">
    
    <link rel="preload" href="/fffBlog/assets/css/0.styles.a74e95d9.css" as="style"><link rel="preload" href="/fffBlog/assets/js/app.46d24954.js" as="script"><link rel="preload" href="/fffBlog/assets/js/2.42a0efeb.js" as="script"><link rel="preload" href="/fffBlog/assets/js/1.99e267a9.js" as="script"><link rel="preload" href="/fffBlog/assets/js/22.61dec9ee.js" as="script"><link rel="prefetch" href="/fffBlog/assets/js/10.70ada020.js"><link rel="prefetch" href="/fffBlog/assets/js/11.6f6d5b08.js"><link rel="prefetch" href="/fffBlog/assets/js/12.c5bb2d7f.js"><link rel="prefetch" href="/fffBlog/assets/js/13.fad9a8f2.js"><link rel="prefetch" href="/fffBlog/assets/js/14.ba24a011.js"><link rel="prefetch" href="/fffBlog/assets/js/15.931aa5a5.js"><link rel="prefetch" href="/fffBlog/assets/js/16.24c53a0b.js"><link rel="prefetch" href="/fffBlog/assets/js/17.fa2974ea.js"><link rel="prefetch" href="/fffBlog/assets/js/18.a01b6027.js"><link rel="prefetch" href="/fffBlog/assets/js/19.80421845.js"><link rel="prefetch" href="/fffBlog/assets/js/20.49fa5db6.js"><link rel="prefetch" href="/fffBlog/assets/js/21.eabefb22.js"><link rel="prefetch" href="/fffBlog/assets/js/23.ad752f2b.js"><link rel="prefetch" href="/fffBlog/assets/js/3.b82ce878.js"><link rel="prefetch" href="/fffBlog/assets/js/4.4423d3ec.js"><link rel="prefetch" href="/fffBlog/assets/js/5.da5f7b06.js"><link rel="prefetch" href="/fffBlog/assets/js/6.079e187d.js"><link rel="prefetch" href="/fffBlog/assets/js/7.53549f25.js"><link rel="prefetch" href="/fffBlog/assets/js/vendors~docsearch.b7a3ab4f.js">
    <link rel="stylesheet" href="/fffBlog/assets/css/0.styles.a74e95d9.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/fffBlog/" class="home-link router-link-active"><!----> <span class="site-name">吴炫境个人博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <!----> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="es6"><a href="#es6" class="header-anchor">#</a> ES6</h1> <h2 id="新特性"><a href="#新特性" class="header-anchor">#</a> 新特性</h2> <p>let,const 变量</p> <p>解构赋值</p> <p>...扩展语法（展开运算符）</p> <p>类class</p> <p>promise</p> <p>模板字符串(<code>${}</code>)</p> <p>剩余参数（...args）</p> <p>模块化（import export）</p> <p>symbol</p> <p>迭代器和生成器</p> <p>map/set</p> <h2 id="generator"><a href="#generator" class="header-anchor">#</a> Generator</h2> <p>生成器，ES6提出的异步编程解决方案，特点：<strong>可以随时暂停函数的执行并且在任意时刻开始函数的执行</strong></p> <p>语法：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//多一个*</span>
<span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">myGenerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//yield关键字</span>
    <span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> fnG <span class="token operator">=</span> <span class="token function">myGenerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//调用返回一个迭代器对象</span>
<span class="token keyword">let</span> <span class="token punctuation">{</span>value<span class="token punctuation">,</span>done<span class="token punctuation">}</span> <span class="token operator">=</span> fnG<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//调用next()方法开始执行，知道yield关键字暂停，直到下一个next函数调用</span>
<span class="token comment">//next函数返回{value,next},value是值yield后面的内容，这里指的是getData函数，done：boolean当为true时代表整个函数已经执行完全，没有yield了</span>
<span class="token comment">//next(arg),将参数传递给上一次停下来的地方，这里会传给const a;</span>

<span class="token comment">//终止生成器</span>
fnG<span class="token punctuation">.</span><span class="token function">return</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//直接终止，后面的yield不执行，done为true</span>
fnG<span class="token punctuation">.</span><span class="token function">throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//抛出异常停止后面的执行,done也是true</span>
</code></pre></div><h2 id="let、const、var区别"><a href="#let、const、var区别" class="header-anchor">#</a> let、const、var区别</h2> <h3 id="var"><a href="#var" class="header-anchor">#</a> var</h3> <p>var会有变量提升，即不管声明在何处，运行时都会提升到作用域的顶部</p> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//输出的是undefined</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">999</span>
<span class="token comment">//为啥不是a未定义？</span>
<span class="token comment">//因为var a这句话提升到最顶部了</span>
<span class="token comment">//为啥不是999？</span>
<span class="token comment">//只提升了var a,a=999的赋值操作还没有跑到</span>
<span class="token comment">//总结：var a = 999是拆分成了声明和赋值两个部分，声明被状态提升到当前作用域顶部</span>
</code></pre></div><p>var在函数内声明，就是局部变量，在函数外声明，就是全局变量</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出2</span>
<span class="token punctuation">}</span>
<span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出1</span>
</code></pre></div><h3 id="let、const"><a href="#let、const" class="header-anchor">#</a> let、const</h3> <p>存在<strong>暂时性死区</strong></p> <p>即在变量声明之前，不能使用</p> <h2 id="函数提升"><a href="#函数提升" class="header-anchor">#</a> 函数提升</h2> <p>分为两种</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//function直接声明函数，提升到顶层</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// foo2</span>
<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'foo2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//以变量赋值的形式----&gt;走变量提升的逻辑</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//undefined</span>
<span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//not a function</span>
<span class="token keyword">var</span> <span class="token function-variable function">bar</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;bar&quot;</span><span class="token punctuation">)</span><span class="token punctuation">}</span>
</code></pre></div><p>时序：<strong>在一个作用域中，先处理函数声明、再处理变量声明，但是两者的优先级依旧低于执行定义语句。</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//1</span>
<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;foo&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="深浅拷贝"><a href="#深浅拷贝" class="header-anchor">#</a> 深浅拷贝</h2> <p><strong>浅拷贝</strong>是创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。<strong>！！！浅拷贝不只是拿到引用</strong> <strong>深拷贝</strong>是将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象。</p> <h3 id="常见浅拷贝方法"><a href="#常见浅拷贝方法" class="header-anchor">#</a> 常见浅拷贝方法</h3> <ul><li><p>Object.assign()</p> <p>Object.assign()不会拷贝对象的继承属性；
Object.assign()不会拷贝对象的不可枚举的属性；
Object.assign()可以拷贝 Symbol 类型的属性。</p></li> <li><p>扩展运算符(…)</p></li> <li><p>Array.prototype.concat()</p></li> <li><p>Array.slice()//实现数组分割，但是不传值的话就是整个浅拷贝</p></li></ul> <h2 id="箭头函数与普通函数的区别"><a href="#箭头函数与普通函数的区别" class="header-anchor">#</a> 箭头函数与普通函数的区别</h2> <p>1.语法简洁性</p> <p>2.this指向不同</p> <p>​	箭头函数没有自己的this，指向外层的this。</p> <p>​	普通函数的this由调用时确定，指向调用它的对象。</p> <p>​	箭头函数无法通过this,call,bind改变this指向</p> <p>3.箭头函数不能作为构造函数</p> <p>4.箭头函数没有arguments对象</p> <h2 id="变量的解构赋值"><a href="#变量的解构赋值" class="header-anchor">#</a> 变量的解构赋值</h2> <h2 id="promise、async-await、generator的区别"><a href="#promise、async-await、generator的区别" class="header-anchor">#</a> promise、async await、Generator的区别</h2> <h2 id="promise-resolve-的用法"><a href="#promise-resolve-的用法" class="header-anchor">#</a> Promise.resolve()的用法</h2> <div class="language-js extra-class"><pre class="language-js"><code>Promise<span class="token punctuation">.</span><span class="token function">reslove</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//无参数或参数为普通值时，返回一个值为value的resolve状态</span>
Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>thenable<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//参数是thenable对象(具有then方法的对象)时，会将这个对象转为promise对象（主要用法）</span>
Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>promise<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//参数是promise对象时，原封不动返回</span>
</code></pre></div><h2 id="promise-try-的用法和使用场景"><a href="#promise-try-的用法和使用场景" class="header-anchor">#</a> Promise.try()的用法和使用场景</h2> <p>场景：当一个函数不好判断是同步/异步函数时或开发者不想判断时，但又想要在函数执行完成后使用then处理接下来的逻辑，这个时候就可以用Promise.resolve(fn).then(()=&gt;{})或Promise.try().then(()=&gt;{})</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//对比</span>
<span class="token comment">//resolve形式的缺点，包装为Promise对象，因此，如果函数是同步函数，也会被变成异步函数进入微任务队列中，执行时机在本轮事件循环的同步代码之后，不是立即执行</span>
<span class="token comment">//当函数内部抛出异常时，捕获不到并且没有返回状态</span>
Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">//try，函数立即执行，能捕获到函数内部的异常</span>
Promise<span class="token punctuation">.</span><span class="token function">try</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h2 id="es6的继承与es5相比有什么不同"><a href="#es6的继承与es5相比有什么不同" class="header-anchor">#</a> ES6的继承与ES5相比有什么不同</h2> <ol><li><p>ES5 的继承实质上是先创建子类的实例对象， 然后再将父类的方法添加
到 this 上（Parent.apply(this)） .</p></li> <li><p>ES6 的继承机制完全不同， 实质上是先创建父类的实例对象 this（所以必
须先调用父类的 super()方法） ， 然后再用子类的构造函数修改 this。</p></li> <li><p>ES5 的继承时通过原型或构造函数机制来实现。</p></li> <li><p>ES6 通过 class 关键字定义类， 里面有构造方法， 类之间通过 extends 关
键字实现继承。</p></li> <li><p>子类必须在 constructor 方法中调用 super 方法， 否则新建实例报错。 因
为子类没有自己的 this 对象， 而是继承了父类的 this 对象， 然后对其进行加工。
如果不调用 super 方法， 子类得不到 this 对象。</p></li> <li><p>注意 super 关键字指代父类的实例， 即父类的 this 对象。</p></li> <li><p>注意： 在子类构造函数中， 调用 super 后， 才可使用 this 关键字， 否则
报错。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//ES5继承</span>
    <span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//父类构造方法</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
    <span class="token punctuation">}</span>
    <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//父类原型链新增方法</span>
      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name
    <span class="token punctuation">}</span>
    <span class="token keyword">function</span> <span class="token function">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//子类构造方法</span>
      <span class="token function">Person</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token comment">//将父类方法加到子类实例</span>
    <span class="token punctuation">}</span>
    <span class="token class-name">Student</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token comment">//修改子类的原型对象</span>
    <span class="token class-name">Student</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Student<span class="token punctuation">;</span><span class="token comment">//上面会改变构造函数，所以再改回来，指向自己的构造函数</span>

</code></pre></div></li></ol> <h2 id="js模块化-commonjs-amd-cmd-es6"><a href="#js模块化-commonjs-amd-cmd-es6" class="header-anchor">#</a> js模块化（commonjs/AMD/CMD/ES6）</h2> <h2 id="回调地狱-如何解决"><a href="#回调地狱-如何解决" class="header-anchor">#</a> 回调地狱，如何解决</h2> <p>回调地狱：回调函数中嵌套回调函数</p> <p>多数在写阻塞执行代码的时候会产生，为了保证异步代码的时序性，通常会在一个异步代码的回调函数中嵌入其它回调函数</p> <div class="language-js extra-class"><pre class="language-js"><code> <span class="token comment">//地狱回调</span>
<span class="token comment">//问题：导致代码可读性差，不方便维护</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">//第一层</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'张三'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//等3秒打印张三在执行下一个回调函数</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">//第二层</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'李四'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//等2秒打印李四在执行下一个回调函数</span>
        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment">//第三层</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'王五'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//等一秒打印王五</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span>
</code></pre></div><p>解决：Promise或async/await</p> <h2 id="原型链"><a href="#原型链" class="header-anchor">#</a> 原型链！！</h2> <p>1，在js中，每一个对象（函数也是对象）都有一个特殊的属性叫做<strong>原型（prorotype）</strong>，它指向另一个对象，这个对象被称为原型对象， ***原型对象是用来共享属性和方法***的</p> <p>2，对象有一个属性(<strong>proto</strong>)指向构造函数的原型对象，构造函数的原型对象也存在__proto__</p> <p>3，原型链的顶端是Object.prototype</p> <p>4，原型链的终点是null</p> <p><img src="/fffBlog/assets/img/prototype.7a6019e4.png" alt="img"></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Cat</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">let</span> cat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
cat<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Cat</span><span class="token punctuation">.</span>prototype
<span class="token class-name">Cat</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Animal</span><span class="token punctuation">.</span>prototype
<span class="token class-name">Animal</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype <span class="token operator">===</span><span class="token keyword">null</span>
<span class="token comment">//得出下面的原型链</span>
cat<span class="token punctuation">.</span>__proto__<span class="token punctuation">.</span>__proto__<span class="token punctuation">.</span>__proto__<span class="token operator">=</span><span class="token keyword">null</span>
</code></pre></div><p>每个对象都有一个原型(prototype),它指向另外一个对象，而指向的对象又存在属性(<em>proto</em>)指向另外一个对象。当我们访问对象(obj3)的属性时，会先在对象定义的属性中进行查找，没找到就会沿着__proto__一路向上查找，最终形成一个链式结构，这整个链式结构就叫做原型链
<strong><strong>proto__存在的意义在于为原型链查找提供方向，原型链查找靠的是__proto</strong>，而不是prototype</strong></p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/fffBlog/assets/js/app.46d24954.js" defer></script><script src="/fffBlog/assets/js/2.42a0efeb.js" defer></script><script src="/fffBlog/assets/js/1.99e267a9.js" defer></script><script src="/fffBlog/assets/js/22.61dec9ee.js" defer></script>
  </body>
</html>
